<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estimation des Prix au m¬≤ en France</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.107/Build/Cesium/Cesium.js"></script>
    <link rel="stylesheet" href="https://cesium.com/downloads/cesiumjs/releases/1.107/Build/Cesium/Widgets/widgets.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
	<!-- Ajout des favicons -->
    <!-- Favicon standard -->
    <link rel="icon" type="image/png" sizes="16x16" href="https://aprz00.github.io/projet_dataviz/favicon/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://aprz00.github.io/projet_dataviz/favicon/favicon-32x32.png">
    <link rel="icon" type="image/x-icon" href="https://aprz00.github.io/projet_dataviz/favicon/favicon.ico">

    <!-- Apple Touch Icon (pour iOS) -->
    <link rel="apple-touch-icon" sizes="180x180" href="https://aprz00.github.io/projet_dataviz/favicon/apple-touch-icon.png">

    <!-- Android Chrome -->
    <link rel="icon" type="image/png" sizes="192x192" href="https://aprz00.github.io/projet_dataviz/favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="https://aprz00.github.io/projet_dataviz/favicon/android-chrome-512x512.png">

    <!-- Web App Manifest (PWA) -->
    <link rel="manifest" href="https://aprz00.github.io/projet_dataviz/favicon/site.webmanifest">
</head>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(90deg, #2c3e50, #3498db);
            color: white;
            padding: 15px 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        header img {
            width: 120px;
            height: auto;
            transition: transform 0.3s ease;
        }

        header img:hover {
            transform: scale(1.1);
        }

        header h1 {
            font-size: 28px;
            font-weight: 600;
            margin-left: 20px;
            flex-grow: 1;
            text-align: center;
        }

        .tab {
            display: flex;
            justify-content: center;
            background: #ffffff;
            border-bottom: 2px solid #3498db;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 5px 0;
            position: sticky;
            top: 70px;
            z-index: 999;
        }

        .tab button {
            background: none;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 400;
            color: #7f8c8d;
            transition: all 0.3s ease;
            border-radius: 5px 5px 0 0;
            margin: 0 5px;
        }

        .tab button:hover {
            color: #3498db;
            background: #f0f0f0;
        }

        .tab button.active {
            color: #ffffff;
            background: #3498db;
            font-weight: 600;
        }

        .tabcontent {
            display: none;
            height: calc(95vh - 150px);
            width: 100%;
            position: relative;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            margin: 20px auto;
            max-width: 1200px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        #Comparison.tabcontent {
            height: auto;
            min-height: calc(95vh - 150px);
            overflow: visible;
        }

        #map, #map3D, #mapComparison {
            height: 100%;
            width: 100%;
            border-radius: 8px;
        }

        .info.legend {
            background: #ffffff;
            padding: 12px;
            font-size: 12px;
            line-height: 18px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3498db;
        }

        .info.legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }

        footer {
            text-align: center;
            background: linear-gradient(90deg, #2c3e50, #3498db);
            color: #ecf0f1;
            padding: 15px 0;
            font-size: 14px;
            margin-top: auto;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }

        footer a {
            color: #ecf0f1;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        footer a:hover {
            color: #ffffff;
            text-decoration: underline;
        }

        #legend3D, #controls3D {
            position: absolute;
            background: #ffffff;
            padding: 12px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            z-index: 998;
            border-left: 4px solid #3498db;
        }

        #legend3D {
            bottom: 20px;
            right: 20px;
        }

        #controls3D {
            top: 70px;
            left: 20px;
        }

        #controls3D select {
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Poppins', sans-serif;
        }

        .leaflet-tooltip {
            font-size: 12px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            border-left: 4px solid #3498db;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            color: #2c3e50;
            font-weight: 500;
        }

        .leaflet-popup-content-wrapper {
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .leaflet-popup-tip {
            background: linear-gradient(135deg, #ffffff, #f0f5ff);
            border-left: 1px solid #3498db;
        }

        /* D√©sactiver les effets de surbrillance par d√©faut de Leaflet pour les clics */
        .leaflet-interactive:focus,
        .leaflet-interactive:active {
            outline: none !important;
            box-shadow: none !important;
        }

        /* √âviter les conflits avec les styles dynamiques appliqu√©s par JavaScript */
        .leaflet-overlay-pane path {
            stroke: black;
            stroke-width: 1px;
            /* Ne pas utiliser !important pour permettre √† setStyle de fonctionner */
        }

        /* Supprimer toute bordure ou effet de surbrillance sp√©cifique au popup */
        .leaflet-popup-content-wrapper {
            border: none !important;
        }

        .leaflet-popup-tip {
            border: none !important;
            background: transparent !important;
        }

        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
            display: none;
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Comparison Tab Styles */
        .comparison-container {
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            padding: 20px;
            background: linear-gradient(135deg, #ffffff 0%, #e6f0fa 100%);
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        }

        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: #3498db;
            color: #fff;
            border-radius: 8px;
        }

        .comparison-title {
            font-size: 24px;
            font-weight: 600;
            margin: 0;
        }

        .comparison-stats {
            font-size: 14px;
            font-weight: 400;
        }

        .comparison-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            z-index: 500;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 14px;
            color: #2c3e50;
            font-weight: 500;
        }

        #yearSlider {
            width: 200px;
            cursor: pointer;
        }

        #yearDisplay {
            margin-left: 10px;
            font-size: 16px;
            color: #2c3e50;
            font-weight: 500;
        }

        #deptSearch {
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Poppins', sans-serif;
            width: 200px;
        }

        .dept-suggestions {
            position: absolute;
            list-style: none;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
            z-index: 501;
            width: 200px;
            display: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-top: 5px;
        }

        .dept-suggestions li {
            padding: 8px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .dept-suggestions li:hover {
            background: #f0f0f0;
        }

        .comparison-map-container {
            height: 600px;
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            margin-bottom: 15px;
        }

        .comparison-chart-container {
            height: 200px;
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 500;
        }

        #mapComparison {
            height: 100%;
            width: 100%;
        }

        .leaflet-control-zoom {
            z-index: 400 !important;
        }

        .leaflet-control {
            z-index: 400 !important;
        }

        /* Map2D Specific Styles */
        .leaflet-container .leaflet-control-search {
            background: #ffffff;
            padding: 8px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3498db;
            font-family: 'Poppins', sans-serif;
        }

        .leaflet-control-search input {
            border: 1px solid #ddd;
            padding: 6px;
            border-radius: 4px;
            font-size: 14px;
            width: 200px;
        }

        .leaflet-control-search ul {
            list-style: none;
            margin: 5px 0 0;
            padding: 0;
            max-height: 150px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .leaflet-control-search li {
            padding: 6px 10px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .leaflet-control-search li:hover {
            background: #f0f0f0;
        }

        .leaflet-control-reset {
            background: #ffffff;
            padding: 8px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3498db;
            font-family: 'Poppins', sans-serif;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #2c3e50;
            transition: background 0.3s ease;
        }

        .leaflet-control-reset:hover {
            background: #f0f0f0;
        }

        .leaflet-control-price-filter {
            background: #ffffff;
            padding: 12px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3498db;
            font-family: 'Poppins', sans-serif;
            width: 200px;
        }

        .leaflet-control-price-filter label {
            font-size: 14px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 8px;
            display: block;
        }

        .leaflet-control-price-filter select {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .leaflet-control-stats {
            background: #ffffff;
            padding: 12px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3498db;
            font-family: 'Poppins', sans-serif;
            width: 250px;
            font-size: 14px;
            color: #2c3e50;
        }

        .leaflet-control-stats h4 {
            margin: 0 0 10px;
            font-size: 16px;
            font-weight: 600;
            color: #3498db;
        }

        .leaflet-control-stats p {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            header h1 { font-size: 20px; }
            header img { width: 90px; }
            .tab button { padding: 10px 15px; font-size: 14px; }
            .tabcontent { height: calc(85vh - 120px); padding: 10px; max-width: 95%; }
            #Comparison.tabcontent { height: auto; min-height: calc(85vh - 120px); }
            .comparison-title { font-size: 20px; }
            .comparison-controls { flex-direction: column; }
            .comparison-map-container { height: 400px; }
            .comparison-chart-container { height: 150px; }
            .leaflet-control-search input,
            .leaflet-control-price-filter,
            .leaflet-control-stats { width: 180px; }
        }
		/* Style sp√©cifique pour les tooltips de la carte de comparaison */
.leaflet-tooltip-comparison {
    font-size: 12px;
    padding: 6px 10px;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 5px;
    border-left: 4px solid #3498db;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    color: #2c3e50;
    font-weight: 500;
}
		 /* Styles pour le menu d√©roulant des communes */
.commune-list-container {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 300px;
    max-height: calc(100% - 40px);
    background: #ffffff;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    display: none; /* Masqu√© par d√©faut */
    flex-direction: column;
    font-family: 'Poppins', sans-serif;
    border-left: 4px solid #3498db;
}

.commune-list-header {
    padding: 12px;
    background: #3498db;
    color: #ffffff;
    border-radius: 8px 8px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.commune-list-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
}

.commune-list-header button {
    background: none;
    border: none;
    color: #ffffff;
    font-size: 14px;
    cursor: pointer;
    padding: 5px 10px;
    transition: background 0.3s ease;
}

.commune-list-header button:hover {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
}

.commune-list {
    max-height: 400px;
    overflow-y: auto;
    padding: 10px;
}

.commune-list ul {
    list-style: none;
    margin: 0;
    padding: 0;
}

.commune-list li {
    padding: 10px;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    transition: background 0.2s ease;
}

.commune-list li:hover {
    background: #f0f5ff;
}

.commune-list li:last-child {
    border-bottom: none;
}

.commune-list li span {
    font-size: 14px;
    color: #2c3e50;
}

.commune-list li .price {
    font-weight: 500;
    color: #3498db;
}

.sort-controls {
    padding: 10px;
    display: flex;
    gap: 10px;
    border-bottom: 1px solid #eee;
    flex-wrap: wrap; /* Ajout pour √©viter le d√©bordement */
}

.sort-controls button {
    padding: 6px 12px;
    background: #3498db;
    color: #ffffff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.3s ease;
    flex: 1; /* Les boutons partagent l'espace √©quitablement */
    min-width: 60px; /* Largeur minimale pour √©viter qu'ils soient trop petits */
}

.sort-controls button:hover {
    background: #2980b9;
}

.sort-controls button.active {
    background: #2c3e50;
}
.commune-info-box {
    position: absolute;
    top: 20px;
    right: 20px;
    background: #ffffff;
    padding: 15px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    font-size: 14px;
    z-index: 998;
    border-left: 4px solid #3498db;
    width: 250px;
    display: none; /* Masqu√© par d√©faut */
    font-family: 'Poppins', sans-serif;
}

.commune-info-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.commune-info-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: #2c3e50;
}

.commune-info-header button {
    background: none;
    border: none;
    font-size: 14px;
    cursor: pointer;
    color: #7f8c8d;
    transition: color 0.3s ease;
}

.commune-info-header button:hover {
    color: #e74c3c;
}

.commune-info-content p {
    margin: 5px 0;
    color: #34495e;
}

.commune-info-content a {
    color: #3498db;
    text-decoration: none;
    font-weight: 500;
}

.commune-info-content a:hover {
    text-decoration: underline;
    color: #2980b9;
}

/* Ajuster la position de la l√©gende pour qu'elle soit en dessous de l'encadr√© */
#legend3D {
    bottom:10px;
    right: 20px;
    top: auto; /* S'assurer qu'elle ne chevauche pas */
}
.histogram-controls {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 1000;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    font-family: 'Poppins', sans-serif;
    display: flex;
    align-items: center;
    gap: 5px;
}

.histogram-controls label {
    font-size: 14px;
    color: #2c3e50;
    margin-right: 5px;
}

.histogram-controls select {
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    background: #fff;
    cursor: pointer;
    transition: border-color 0.3s ease;
}

.histogram-controls select:focus {
    outline: none;
    border-color: #3498db;
}

/* S'assurer que le canvas prend toute la place */
#histogramChart {
    width: 100%;
    height: 100%;
}

/* Styles sp√©cifiques pour l'onglet Accueil */
#Accueil .intro-text {
    font-size: 18px;
    font-weight: 300;
    line-height: 1.8;
    margin-bottom: 20px;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
}

#Accueil h3 {
    color: #2c3e50;
    font-size: 24px;
    margin: 30px 0 15px;
    position: relative;
    text-align: left;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
}

#Accueil h3::before {
    content: '';
    position: absolute;
    left: 0;
    bottom: -5px;
    width: 50px;
    height: 3px;
    background: #3498db;
}

#Accueil p {
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
}

#Accueil .section-divider {
    width: 100%;
    max-width: 800px;
    height: 1px;
    background: #ddd;
    margin: 40px auto;
}

#Accueil .tab-description {
    background: #f9f9f9;
    padding: 20px;
    border-radius: 8px;
    margin: 20px auto;
    max-width: 800px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    transition: transform 0.3s ease;
}

#Accueil .tab-description:hover {
    transform: translateY(-5px);
}

#Accueil .tab-description h4 {
    color: #3498db;
    font-size: 20px;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
}

#Accueil .tab-description p {
    margin-bottom: 10px;
    color: #34495e;
}

#Accueil .outro-text {
    font-size: 18px;
    font-weight: 500;
    color: #2c3e50;
    margin-top: 40px;
    text-align: center;
}
.tabcontent.active {
    display: block !important;
}
/* Style pour l'onglet Accueil */
#Accueil {
    max-height: 80vh; /* Limite la hauteur √† 80% de la hauteur de la fen√™tre */
    overflow-y: auto; /* Ajoute une barre de d√©filement verticale si le contenu d√©passe */
    padding: 20px; /* Garde un peu d'espace autour du texte */
    box-sizing: border-box; /* S'assure que le padding est inclus dans la hauteur */
}
/* Style pour l'onglet Infographie */
#Infographie {
    padding: 20px;
    box-sizing: border-box;
}

/* Conteneur de l'infographie */
.infographie-container {
    position: relative;
    max-width: 100%;
    margin: 20px 0;
    text-align: center;
}

/* Style de l'image */
#infographieImage {
    max-width: 100%;
    height: auto;
    border: 1px solid #ccc;
    border-radius: 5px;
    transition: all 0.3s ease;
}

/* Style du bouton plein √©cran */
#fullscreenBtn {
    position: absolute;
    top: 10px; /* Position en haut */
    right: 10px; /* Position √† droite */
    padding: 8px 15px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.3s ease;
}

#fullscreenBtn:hover {
    background-color: #0056b3;
}

/* Style pour le mode plein √©cran */
#infographieImage.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    object-fit: contain; /* S'assure que l'image reste proportionnelle */
    background-color: rgba(0, 0, 0, 0.9); /* Fond sombre pour le mode plein √©cran */
    z-index: 1000;
    border: none;
    margin: 0;
    padding: 0;
}

/* Ajuster le bouton en mode plein √©cran */
#fullscreenBtn.fullscreen {
    position: fixed;
    top: 20px; /* Garde le bouton en haut √† droite en mode plein √©cran */
    right: 20px;
    z-index: 1001;
}
#Infographie {
    max-height: 80vh;
    overflow-y: auto;
    padding: 20px;
    box-sizing: border-box;
}



    </style>
</head>
<body>

<header>
    <img src="https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/Logo_site.jpg" alt="Logo_site">
    <h1>Estimation des valeurs fonci√®res au m¬≤ en France</h1>
</header>

<!-- Boutons des onglets -->
<div class="tab">
    <button class="tablinks" onclick="openTab(event, 'Accueil')" id="defaultOpen">Accueil</button>
    <button class="tablinks" onclick="openTab(event, 'Map2D')">Carte 2D</button>
    <button class="tablinks" onclick="openTab(event, 'Map3D')">Carte 3D</button>
    <button class="tablinks" onclick="openTab(event, 'Histogram')">Histogramme</button>
    <button class="tablinks" onclick="openTab(event, 'Comparison')">Evolution 2014-2023</button>
    <button class="tablinks" onclick="openTab(event, 'Infographie')">Infographie</button>
</div>

<!-- Onglet Accueil -->
<div id="Accueil" class="tabcontent">
    <h2>Bienvenue sur notre site d√©di√© aux valeurs fonci√®res !</h2>
    <p class="intro-text">
        Ce site vous permet de visualiser les prix des <strong>valeurs fonci√®res</strong> en France, √† l‚Äô√©chelle des d√©partements et des communes. Il est organis√© en plusieurs parties, dont celle sur laquelle vous vous trouvez actuellement : la page d‚Äôaccueil. C‚Äôest ici que vous trouverez toutes les explications n√©cessaires concernant les diff√©rentes sections du site.
    </p>
    <p class="intro-text">
        Les autres onglets contiennent peu (voire pas du tout) de texte explicatif, donc si vous vous sentez un peu perdu¬∑e, n‚Äôh√©sitez pas √† revenir ici üòä.
    </p>

    <div class="section-divider"></div>

    <h3>D‚Äôo√π viennent les donn√©es ?</h3>
    <p>
        Toutes les cartes que vous allez d√©couvrir ont √©t√© r√©alis√©es √† partir des donn√©es <strong>DVF (Demandes de Valeurs Fonci√®res)</strong>, disponibles sur <a href="https://www.data.gouv.fr" target="_blank">data.gouv.fr</a>. Ces donn√©es regroupent les informations immobili√®res (prix, types de biens, surfaces, etc.) par commune et par ann√©e, sur la p√©riode <strong>2014 √† 2023</strong>.
    </p>
    <p>
        Nous avons retravaill√© ces donn√©es pour pouvoir les exploiter au mieux sur ce site. Les fichiers GeoJSON utilis√©s pour afficher les communes et d√©partements proviennent √©galement de data.gouv.
    </p>

    <div class="section-divider"></div>

    <h3>√Ä noter</h3>
    <p>
        La base DVF est publique et g√©r√©e par la <strong>DGFiP</strong>. Elle pr√©sente l‚Äôavantage d‚Äô√™tre gratuite et transparente, mais elle peut parfois √™tre complexe √† utiliser. Certaines transactions, notamment les ventes multilignes (plusieurs biens regroup√©s), peuvent fausser les r√©sultats.
    </p>
    <p>
        Il existe une version enrichie appel√©e <strong>DVF+</strong>, propos√©e par le Cerema, qui structure et g√©olocalise les donn√©es de mani√®re plus fiable. Cependant, nous ne l‚Äôavons pas utilis√©e car nous en avons eu connaissance trop tard. Notre site repose donc uniquement sur la version brute de la DVF, ce qui peut entra√Æner certaines impr√©cisions (comme des prix anormalement √©lev√©s dans certaines communes).
    </p>

    <div class="section-divider"></div>

    <h3>Que trouve-t-on dans les onglets ?</h3>

    <div class="tab-description">
        <h4>üó∫Ô∏è Onglet 2 ‚Äî Carte 2D interactive</h4>
        <p>
            Vous trouverez ici une carte en 2D de la France, qui affiche les moyennes des valeurs fonci√®res par d√©partement. Vous pouvez aussi rechercher une commune pour consulter sa moyenne.
        </p>
        <p>
            L‚Äôinterface est simple et repose principalement sur le clic de souris ou la recherche par nom. En cliquant sur un d√©partement, un menu d√©roulant s‚Äôaffiche : il liste toutes ses communes, que vous pouvez trier selon diff√©rents crit√®res.
        </p>
        <p>
            Enfin, en cliquant sur une commune, vous verrez appara√Ætre plusieurs infos utiles, dont un lien vers sa page Wikip√©dia (chaque commune est li√©e √† sa fiche Wikip√©dia !).
        </p>
    </div>

    <div class="tab-description">
        <h4>üåç Onglet 3 ‚Äî Carte 3D</h4>
        <p>
            Ici, vous retrouvez les m√™mes valeurs fonci√®res que dans l‚Äôonglet pr√©c√©dent, mais sous forme de carte 3D. Chaque commune est repr√©sent√©e par un polygone dont la hauteur varie en fonction de la valeur fonci√®re moyenne (c‚Äôest ce qu‚Äôon appelle l‚Äôextrusion avec la variable Z).
        </p>
        <p>
            Vous pouvez filtrer l‚Äôaffichage en s√©lectionnant un d√©partement dans le menu √† gauche : seul le d√©partement choisi restera visible. Et comme dans l‚Äôonglet pr√©c√©dent, en cliquant sur une commune, des informations s‚Äôaffichent (cette fois en haut √† droite de la carte).
        </p>
    </div>

    <div class="tab-description">
        <h4>üìä Onglet 4 ‚Äî Histogramme des d√©partements</h4>
        <p>
            Cet onglet propose un histogramme comparatif des d√©partements les plus chers et les moins chers. Vous pouvez trier cet histogramme pour une meilleure lecture, et il utilise les m√™mes couleurs que les cartes pr√©c√©dentes pour garder une coh√©rence visuelle.
        </p>
        <p>
            Cela vous permet de faire facilement le lien entre la carte et le graphique.
        </p>
    </div>

    <div class="tab-description">
        <h4>‚è≥ Onglet 5 ‚Äî √âvolution dans le temps</h4>
        <p>
            Cette carte reprend la moyenne des valeurs fonci√®res par d√©partement, mais avec une dimension temporelle. Un curseur en haut √† gauche permet de revenir dans le pass√©, jusqu‚Äôen 2014. (Les donn√©es ant√©rieures ne sont pas disponibles.)
        </p>
        <p>
            En cliquant sur un d√©partement, un pop-up affiche les infos principales. Ce pop-up reste visible m√™me si vous changez d‚Äôann√©e, ce qui est tr√®s pratique pour comparer rapidement les prix entre 2023 et les ann√©es pr√©c√©dentes.
        </p>
        <p>
            En bas de cette page, un graphique montre l‚Äô√©volution des prix moyens en France. Sans surprise, les prix ont augment√© entre 2014 et 2023 üìà.
        </p>
    </div>

    <div class="tab-description">
        <h4>üñºÔ∏è Onglet 6 ‚Äî Infographie : focus sur le littoral du Sud-Est</h4>
        <p>
            Dans cette derni√®re partie, vous trouverez une infographie que nous avons r√©alis√©e avec Flourish. Elle se concentre sur cinq d√©partements littoraux du Sud-Est : <strong>Gard, H√©rault, Bouches-du-Rh√¥ne, Var et Alpes-Maritimes</strong>.
        </p>
        <p>
            Notre objectif √©tait de mettre en lumi√®re les √©carts de prix entre ces territoires. On observe par exemple une fracture r√©gionale nette entre l‚ÄôH√©rault/Gard (plus abordables) et les Bouches-du-Rh√¥ne, le Var et les Alpes-Maritimes (nettement plus chers).
        </p>
        <p>
            L‚Äôinfographie utilise les m√™mes donn√©es DVF que le reste du site, pour une coh√©rence totale.
        </p>
    </div>

    <div class="section-divider"></div>

    <p class="outro-text">
        Pour commencer, s√©lectionnez un onglet dans la barre de navigation ci-dessus !
    </p>
</div>

<!-- Onglet Map2D -->
<div id="Map2D" class="tabcontent">
    <div id="map"></div>
    <div id="communeListContainer" class="commune-list-container">
        <div class="commune-list-header">
            <h3 id="communeListTitle">Communes</h3>
            <button id="closeCommuneListBtn">Fermer</button>
        </div>
        <div class="sort-controls">
            <button id="sortAsc">Prix ‚Üë</button>
            <button id="sortDesc">Prix ‚Üì</button>
            <button id="sortAlphaAsc">A √† Z</button>
            <button id="sortAlphaDesc">Z √† A</button>
        </div>
        <div class="commune-list">
            <ul id="communeList"></ul>
        </div>
    </div>
</div>

<!-- Onglet Map3D -->
<div id="Map3D" class="tabcontent">
    <div id="map3D"></div>
    <div id="loadingSpinner" class="loading-spinner">
        <div class="spinner"></div>
    </div>
    <!-- Ajout de l'encadr√© pour les informations de la commune -->
    <div id="communeInfoBox" class="commune-info-box">
        <div class="commune-info-header">
            <h3 id="communeInfoTitle">Informations sur la commune</h3>
            <button id="closeCommuneInfoBtn">‚úñ</button>
        </div>
        <div class="commune-info-content">
            <p><strong>Nom :</strong> <span id="communeInfoName">S√©lectionnez une commune</span></p>
            <p><strong>Code commune :</strong> <span id="communeInfoCode">N/A</span></p>
            <p><strong>Prix moyen :</strong> <span id="communeInfoPrice">N/A</span></p>
            <p><a id="communeInfoWikiLink" href="#" target="_blank">Voir sur Wikip√©dia</a></p>
        </div>
    </div>
</div>

<!-- Onglet Histogram -->
<div id="Histogram" class="tabcontent">
    <!-- Menu de tri -->
    <div id="histogramControls" class="histogram-controls">
        <label for="sortOptions"><b>Trier par :</b></label>
        <select id="sortOptions">
            <option value="priceDesc">Prix : Plus √©lev√© ‚Üí Plus bas</option>
            <option value="priceAsc">Prix : Plus bas ‚Üí Plus √©lev√©</option>
            <option value="deptAsc">D√©partement : 01 ‚Üí 95</option>
            <option value="deptDesc">D√©partement : 95 ‚Üí 01</option>
        </select>
    </div>
    <!-- Remplacer div par canvas -->
    <canvas id="histogramChart"></canvas>
</div>

<!-- Onglet Comparison -->
<div id="Comparison" class="tabcontent">
    <div id="comparisonContainer" class="comparison-container">
        <div class="comparison-header">
            <h2 class="comparison-title">√âvolution des moyennes des valeurs fonci√®res au m¬≤ par d√©partement (2014-2023)</h2>
            <div class="comparison-stats">
                <p><strong>Moyenne nationale :</strong> <span id="nationalAverage">Chargement...</span> ‚Ç¨/m¬≤</p>
            </div>
        </div>
        <div class="comparison-controls">
            <div class="control-group">
                <label for="yearSlider">Ann√©e :</label>
                <input type="range" id="yearSlider" min="2014" max="2023" value="2023" oninput="updateYearSlider()">
                <span id="yearDisplay">2023</span>
            </div>
            <div class="control-group">
                <label for="deptSearch">Rechercher un d√©partement :</label>
                <input type="text" id="deptSearch" placeholder="Ex: 75 ou Paris" oninput="filterDepartments()">
                <ul id="deptSuggestions" class="dept-suggestions"></ul>
            </div>
        </div>
        <div class="comparison-map-container">
            <div id="mapComparison" class="comparison-map"></div>
        </div>
        <div class="comparison-chart-container">
            <canvas id="priceTrendChart"></canvas>
        </div>
    </div>
</div>

<!-- Onglet Infographie -->
<div id="Infographie" class="tabcontent">
    <h2>Infographie : Focus sur le littoral du Sud-Est</h2>
    <p>
        Cette section pr√©sente une infographie mettant en lumi√®re les √©carts de prix immobiliers dans cinq d√©partements littoraux du Sud-Est : Gard, H√©rault, Bouches-du-Rh√¥ne, Var et Alpes-Maritimes.
    </p>
    <p>
        <b>Points cl√©s :</b><br>
        - Une fracture r√©gionale nette entre l‚ÄôH√©rault/Gard (plus abordables) et les Bouches-du-Rh√¥ne, le Var et les Alpes-Maritimes (nettement plus chers).<br>
        - Visualisation des tendances et des √©carts de prix entre ces d√©partements.
    </p>
    <div class="infographie-container">
        <img id="infographieImage" src="https://raw.githubusercontent.com/Aprz00/projet_dataviz/430d10ef18aba5bf2e60b9a6015549c02697a96c/Infographie.png" alt="Infographie sur les prix immobiliers du littoral Sud-Est">
        <button id="fullscreenBtn" onclick="toggleFullscreen()">Plein √©cran</button>
    </div>
</div>

<!-- Pied de page -->
<footer class="site-footer">
    <p>Pour plus d'informations, <a href="https://github.com/Aprz00/projet_dataviz/tree/main" target="_blank" rel="noopener noreferrer">contactez-nous</a> sur GitHub !</p>
</footer>

<script>
// Global Variables
let map = null;
let departementsLayer = null;
let communesLayer = null;
let prixCommuneData = {};
let mapComparison = null;
let priceTrendChart = null;
let highlightedDeptLayer = null;
let currentDeptCode = null; // Pour suivre le d√©partement actuellement s√©lectionn√©
let communeDataList = []; // Pour stocker les donn√©es des communes √† afficher dans le menu
let deptNames = {};
let communeNames = {};

// Tab Management
function openTab(evt, tabName) {
    console.log("Ouverture de l'onglet :", tabName); // Ajout d'un log pour d√©boguer
    const tabcontent = document.getElementsByClassName("tabcontent");
    const tablinks = document.getElementsByClassName("tablinks");

    // Cacher tous les onglets
    for (let i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
        tabcontent[i].classList.remove("active"); // Retirer la classe active
    }

    // Retirer la classe active de tous les boutons
    for (let i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Afficher l'onglet s√©lectionn√© et ajouter la classe active
    const selectedTab = document.getElementById(tabName);
    if (selectedTab) {
        selectedTab.style.display = "block";
        selectedTab.classList.add("active"); // Ajouter la classe active
        evt.currentTarget.className += " active";
    } else {
        console.error(`L'onglet avec id='${tabName}' n'a pas √©t√© trouv√©.`);
    }

    // Initialisation des onglets sp√©cifiques
    if (tabName === 'Map2D' && !window.leafletInitialized) {
        initLeafletMap();
        window.leafletInitialized = true;
    } else if (tabName === 'Map3D') {
        if (!window.cesiumInitialized) {
            initCesium();
            window.cesiumInitialized = true;
        } else if (window.cesiumViewer) {
            window.cesiumViewer.scene.requestRender();
            window.cesiumViewer.resize();
        }
    } else if (tabName === 'Histogram' && !window.histogramInitialized) {
        initHistogram();
        window.histogramInitialized = true;
    } else if (tabName === 'Comparison' && !window.comparisonInitialized) {
        initComparison();
        window.comparisonInitialized = true;
    }
}

// Initialisation de l'onglet par d√©faut
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM charg√©, ouverture de l'onglet par d√©faut...");
    const defaultTab = document.getElementById("defaultOpen");
    if (defaultTab) {
        defaultTab.click();
    } else {
        console.error("L'√©l√©ment avec id='defaultOpen' n'a pas √©t√© trouv√©.");
    }
});

// Utility Functions
function getColor(prix) {
    return prix < 1000 ? '#F5F5DC' :
           prix > 4000 ? '#800026' :
           prix > 3500 ? '#BD0026' :
           prix > 3000 ? '#E31A1C' :
           prix > 2500 ? '#FC4E2A' :
           prix > 2000 ? '#FD8D3C' :
           prix > 1500 ? '#FEB24C' :
           prix >= 1000 ? '#FED976' :
                          '#808080';
}

function getWikipediaUrl(communeName) {
    if (typeof communeName !== 'string' || !communeName) {
        return 'https://fr.wikipedia.org/wiki/Nom_non_d√©fini';
    }
    const formattedName = encodeURIComponent(communeName.replace(/ /g, '_'));
    return `https://fr.wikipedia.org/wiki/${formattedName}`;
}

// Fonction pour normaliser les cha√Ænes (supprimer les accents)
function normalizeString(str) {
    if (!str) return '';
    return str
        .normalize('NFD') // D√©composer les caract√®res accentu√©s
        .replace(/[\u0300-\u036f]/g, '') // Supprimer les diacritiques
        .toLowerCase();
}

// 2D Map (2023)
function initLeafletMap() {
    console.log("Initialisation de la carte Leaflet pour Map2D...");
    // D√©finir les limites g√©ographiques de la France m√©tropolitaine
    const franceBounds = [
        [41.5, -5.5], // Coin sud-ouest (lat, lng)
        [51.5, 9.5]   // Coin nord-est (lat, lng)
    ];

    map = L.map('map', {
        zoomAnimation: true,
        zoomDelta: 0.5,
        zoomSnap: 0.5,
        maxZoom: 14,
        minZoom: 5,
        // Ajouter les limites pour emp√™cher de sortir de la France m√©tropolitaine
        maxBounds: franceBounds,
        maxBoundsViscosity: 1.0, // Emp√™che compl√®tement le d√©placement hors des limites
        bounceAtZoomLimits: false // D√©sactive le rebond aux limites de zoom
    }).setView([46.5, 2.0], 5.5);

    const initialView = { center: [46.5, 2.0], zoom: 5.5 };

    const Esri_WorldGrayCanvas = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles ¬© Esri ‚Äî Esri, DeLorme, NAVTEQ',
        maxZoom: 16
    }).addTo(map);

    let prixData = {};
    let prixCommuneData = {};
    let searchHighlightedLayer = null; // Variable pour suivre la couche mise en surbrillance

    // Fonction pour calculer le centro√Øde d'un polygone (approximation simple)
    function calculateCentroid(coordinates) {
        let latSum = 0, lngSum = 0, numPoints = 0;

        function processCoords(coords) {
            coords.forEach(coord => {
                if (Array.isArray(coord[0])) { // Si c'est un tableau de coordonn√©es (Polygon ou MultiPolygon)
                    processCoords(coord);
                } else { // Si c'est une paire [lng, lat]
                    lngSum += coord[0];
                    latSum += coord[1];
                    numPoints++;
                }
            });
        }

        processCoords(coordinates);
        return [latSum / numPoints, lngSum / numPoints]; // [lat, lng]
    }

    // Fonction pour centrer une commune sur la carte
    function centerCommune(layer, applyOffset = true) {
        const bounds = layer.getBounds();
        const center = bounds.getCenter();
        const desiredZoom = 13;

        // V√©rifier que le centre est dans les limites avant de d√©placer
        const boundedCenter = [
            Math.max(franceBounds[0][0], Math.min(franceBounds[1][0], center.lat)),
            Math.max(franceBounds[0][1], Math.min(franceBounds[1][1], center.lng))
        ];

        map.setView(boundedCenter, desiredZoom, { animate: true });

        setTimeout(() => {
            if (applyOffset) {
                const container = document.getElementById('communeListContainer');
                const menuWidth = container ? (container.offsetWidth || 300) : 300;
                const mapSize = map.getSize();
                const mapWidth = mapSize.x;
                const offsetPixels = menuWidth * 0.35;
                const currentZoom = map.getZoom();
                const centerPoint = map.project(boundedCenter, currentZoom);
                centerPoint.x -= offsetPixels;
                const adjustedCenter = map.unproject(centerPoint, currentZoom);

                // S'assurer que le centre ajust√© reste dans les limites
                const boundedAdjustedCenter = [
                    Math.max(franceBounds[0][0], Math.min(franceBounds[1][0], adjustedCenter.lat)),
                    Math.max(franceBounds[0][1], Math.min(franceBounds[1][1], adjustedCenter.lng))
                ];

                map.setView(boundedAdjustedCenter, desiredZoom, { animate: true });
            }
        }, 300);
    }

    // Fonction pour appliquer un d√©calage lors de la recherche
    function adjustCenterForSearch(center, zoom) {
        setTimeout(() => {
            const container = document.getElementById('communeListContainer');
            const menuWidth = container ? (container.offsetWidth || 300) : 300;
            const mapSize = map.getSize();
            const mapWidth = mapSize.x;
            const offsetPixels = menuWidth * 0.35;
            const currentZoom = map.getZoom();
            const centerPoint = map.project(center, currentZoom);
            centerPoint.x -= offsetPixels;
            const adjustedCenter = map.unproject(centerPoint, currentZoom);

            // S'assurer que le centre ajust√© reste dans les limites
            const boundedAdjustedCenter = [
                Math.max(franceBounds[0][0], Math.min(franceBounds[1][0], adjustedCenter.lat)),
                Math.max(franceBounds[0][1], Math.min(franceBounds[1][1], adjustedCenter.lng))
            ];

            map.setView(boundedAdjustedCenter, zoom, { animate: true });
        }, 300);
    }

    Promise.all([
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/prix_m2_moyenne_par_departement.csv').then(response => response.text()),
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/contour-des-departements.geojson').then(response => response.json()),
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/prix_m2_moyenne_par_commune.csv').then(response => response.text()),
        fetch('https://www.data.gouv.fr/fr/datasets/r/fb3580f6-e875-408d-809a-ad22fc418581').then(response => response.json())
    ]).then(([deptCsvText, geojsonData, communeCsvText, communeGeojsonData]) => {
        // Process department data (2023)
        let deptRows = deptCsvText.split("\n").map(row => row.split(";"));
        deptRows.forEach(row => {
            let code_dep = row[0]?.trim();
            let prix = parseFloat(row[1]);
            if (code_dep && !isNaN(prix)) prixData[code_dep] = prix;
        });

        // Process commune data
        let communeRows = communeCsvText.split("\n").map(row => row.split(";"));
        communeRows.forEach(row => {
            let code_commune = row[0]?.trim().padStart(5, '0');
            let prix = parseFloat(row[1]);
            if (code_commune && !isNaN(prix)) prixCommuneData[code_commune] = prix;
        });

        // Store department names with normalized version for search
        geojsonData.features.forEach(feature => {
            let code = feature.properties.code.toString().trim();
            let name = feature.properties.nom || 'Nom non d√©fini';
            deptNames[code] = {
                name: name,
                normalizedName: normalizeString(name)
            };
        });

        // Store commune names and coordinates for search with normalized version
        communeGeojsonData.features.forEach(feature => {
            let codeCommune = feature.properties.codgeo;
            let communeName = feature.properties.libgeo || 'Nom non d√©fini';
            let depCode = feature.properties.dep ? feature.properties.dep.toString().padStart(2, '0') : null;
            let coordinates = null;
            let centroid = null;

            if (feature.geometry.type === "Polygon") {
                coordinates = feature.geometry.coordinates[0];
                centroid = calculateCentroid([coordinates]);
            } else if (feature.geometry.type === "MultiPolygon") {
                coordinates = feature.geometry.coordinates[0][0];
                centroid = calculateCentroid(feature.geometry.coordinates);
            }

            if (centroid) {
                communeNames[codeCommune] = {
                    name: communeName,
                    normalizedName: normalizeString(communeName),
                    dep: depCode,
                    depName: deptNames[depCode]?.name || 'Inconnu',
                    lat: centroid[0],
                    lng: centroid[1]
                };
            }
        });

        function getLayerStyle(feature, prixDataSource, isHighlighted = false, isFaded = false, isSelected = false) {
            let code = feature.properties.code ? feature.properties.code.toString().trim() : feature.properties.codgeo;
            let prix = prixDataSource[code];
            let fillColor = getColor(prix);

            if (isSelected) {
                return {
                    fillColor: fillColor,
                    weight: 1,
                    opacity: 1,
                    color: 'black',
                    fillOpacity: 0
                };
            }

            if (isHighlighted) {
                return {
                    fillColor: fillColor,
                    weight: 3,
                    opacity: 1,
                    color: '#FFFFFF',
                    fillOpacity: 0.9
                };
            }

            if (isFaded) {
                return {
                    fillColor: fillColor,
                    weight: 1,
                    opacity: 0.3,
                    color: 'black',
                    fillOpacity: 0.3
                };
            }

            return {
                fillColor: prix !== undefined ? fillColor : '#808080',
                weight: 1,
                opacity: 1,
                color: 'black',
                fillOpacity: 0.7
            };
        }

        function updateLayer() {
            if (departementsLayer) map.removeLayer(departementsLayer);
            if (communesLayer) map.removeLayer(communesLayer);

            departementsLayer = L.geoJSON(geojsonData, {
                style: function(feature) {
                    const deptCode = feature.properties.code.toString().padStart(2, '0');
                    return getLayerStyle(feature, prixData, false, false, deptCode === currentDeptCode);
                },
                interactive: true,
                onEachFeature: function(feature, layer) {
                    let code = feature.properties.code.toString().padStart(2, '0');
                    let prix = prixData[code] ? prixData[code].toFixed(1) + " ‚Ç¨/m¬≤" : "Donn√©e non disponible";
                    let nom = deptNames[code]?.name || 'Nom non d√©fini';

                    const initialStyle = getLayerStyle(feature, prixData, false, false, code === currentDeptCode);
                    layer.defaultStyle = initialStyle;
                    layer.currentStyle = initialStyle;

                    const popupContent = `
                        <div class="custom-popup">
                            <h3>${nom}</h3>
                            <p><strong>Code :</strong> ${code}</p>
                            <p><strong>Prix moyen (2023) :</strong> ${prix}</p>
                        </div>
                    `;

                    layer.bindTooltip(`${nom}<br>${prix}`, { direction: 'top', offset: [0, -10] });
                    layer.bindPopup(popupContent, {
                        className: 'custom-popup',
                        autoPan: true,
                        closeOnClick: true,
                        autoClose: true
                    });

                    layer.on('mouseover', function() {
                        if (layer !== searchHighlightedLayer) {
                            layer.setStyle({
                                weight: 3,
                                color: '#000',
                                fillOpacity: 1
                            });
                        }
                        layer.openTooltip();
                        updateStatsPanel(nom, code, prix);
                    });

                    layer.on('mouseout', function() {
                        if (layer !== searchHighlightedLayer) {
                            layer.setStyle(layer.currentStyle);
                        }
                        layer.closeTooltip();
                        updateStatsPanel();
                    });

                    layer.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        const bounds = layer.getBounds();
                        map.fitBounds(bounds, { maxZoom: 9, animate: true });
                        loadCommuneLayer(code);
                        highlightSearchResult(code, true);
                        layer.openPopup();
                    });

                    layer.on('popupclose', function() {
                        if (layer !== searchHighlightedLayer) {
                            layer.setStyle(layer.currentStyle);
                        }
                    });
                }
            }).addTo(map);

            departementsLayer.eachLayer(function(layer) {
                const deptCode = layer.feature.properties.code.toString().padStart(2, '0');
                layer.setStyle(getLayerStyle(layer.feature, prixData, false, false, deptCode === currentDeptCode));
                layer.currentStyle = getLayerStyle(layer.feature, prixData, false, false, deptCode === currentDeptCode);
            });

            updateLegend();
        }

        function loadCommuneLayer(codeDepartement, displayList = true) {
            if (communesLayer) {
                map.removeLayer(communesLayer);
            }

            currentDeptCode = codeDepartement;
            communeDataList = [];

            communesLayer = L.geoJSON(communeGeojsonData, {
                filter: function(feature) {
                    let dep = feature.properties.dep ? feature.properties.dep.toString().padStart(2, '0') : null;
                    return dep === codeDepartement;
                },
                style: function(feature) {
                    return getLayerStyle(feature, prixCommuneData, false, false);
                },
                interactive: true,
                onEachFeature: function(feature, layer) {
                    let codeCommune = feature.properties.codgeo;
                    let prix = prixCommuneData[codeCommune] ? parseFloat(prixCommuneData[codeCommune]).toFixed(1) : null;
                    let communeName = communeNames[codeCommune]?.name || 'Nom non d√©fini';
                    let depCode = feature.properties.dep ? feature.properties.dep.toString().padStart(2, '0') : null;

                    if (prix !== null && !isNaN(parseFloat(prix))) {
                        communeDataList.push({
                            code: codeCommune,
                            name: communeName,
                            price: parseFloat(prix),
                            layer: layer
                        });
                    }

                    const initialStyle = getLayerStyle(feature, prixCommuneData, false, false);
                    layer.defaultStyle = initialStyle;
                    layer.currentStyle = initialStyle;

                    const popupContent = `
                        <div class="custom-popup">
                            <h3>${communeName}</h3>
                            <p><strong>Code :</strong> ${codeCommune}</p>
                            <p><strong>D√©partement :</strong> ${deptNames[depCode]?.name || 'Inconnu'} (D√©p. ${depCode})</p>
                            <p><strong>Prix moyen :</strong> ${prix || "Donn√©e non disponible"} ‚Ç¨/m¬≤</p>
                            <a href="${getWikipediaUrl(communeName)}" target="_blank">Voir sur Wikip√©dia</a>
                        </div>
                    `;

                    layer.bindTooltip(`${communeName}<br>${prix || "Donn√©e non disponible"} ‚Ç¨/m¬≤`, { direction: 'top', offset: [0, -10] });
                    layer.bindPopup(popupContent, {
                        className: 'custom-popup',
                        autoPan: true,
                        closeOnClick: true,
                        autoClose: true
                    });

                    layer.on('mouseover', function() {
                        if (prixCommuneData[codeCommune] !== undefined && layer !== searchHighlightedLayer) {
                            layer.setStyle({
                                weight: 3,
                                color: '#000',
                                fillOpacity: 1
                            });
                            layer.openTooltip();
                            updateStatsPanel(communeName, codeCommune, prix || "Donn√©e non disponible", deptNames[depCode]?.name);
                        }
                    });

                    layer.on('mouseout', function() {
                        if (prixCommuneData[codeCommune] !== undefined && layer !== searchHighlightedLayer) {
                            layer.setStyle(layer.currentStyle);
                            layer.closeTooltip();
                            updateStatsPanel();
                        }
                    });

                    layer.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        centerCommune(layer);
                        highlightSearchResult(codeCommune, false);
                        layer.openPopup();
                    });

                    layer.on('popupclose', function() {
                        if (layer !== searchHighlightedLayer) {
                            layer.setStyle(layer.currentStyle);
                        }
                    });
                }
            }).addTo(map);

            communesLayer.eachLayer(function(layer) {
                layer.setStyle(getLayerStyle(layer.feature, prixCommuneData, false, false));
                layer.currentStyle = getLayerStyle(layer.feature, prixCommuneData, false, false);
            });

            if (searchHighlightedLayer && !searchHighlightedLayer.feature.properties.code) {
                highlightSearchResult(searchHighlightedLayer.feature.properties.codgeo, false);
            }

            if (displayList) {
                displayCommuneList(codeDepartement);
            }

            departementsLayer.eachLayer(layer => {
                const deptCode = layer.feature.properties.code.toString().padStart(2, '0');
                if (deptCode === currentDeptCode) {
                    const selectedStyle = getLayerStyle(layer.feature, prixData, false, false, true);
                    layer.setStyle(selectedStyle);
                    layer.currentStyle = selectedStyle;
                } else {
                    const fadedStyle = getLayerStyle(layer.feature, prixData, false, true);
                    layer.setStyle(fadedStyle);
                    layer.currentStyle = fadedStyle;
                }
            });
        }

        function displayCommuneList(deptCode) {
            const container = document.getElementById('communeListContainer');
            const title = document.getElementById('communeListTitle');
            const list = document.getElementById('communeList');
            const deptName = deptNames[deptCode]?.name || 'D√©partement inconnu';

            title.textContent = `Communes de ${deptName}`;
            sortCommunes('asc');
            container.style.display = 'flex';
        }

        function sortCommunes(order) {
            const list = document.getElementById('communeList');
            const sortAscBtn = document.getElementById('sortAsc');
            const sortDescBtn = document.getElementById('sortDesc');
            const sortAlphaAscBtn = document.getElementById('sortAlphaAsc');
            const sortAlphaDescBtn = document.getElementById('sortAlphaDesc');

            if (!communeDataList || communeDataList.length === 0) {
                list.innerHTML = '<li>Aucune commune disponible</li>';
                return;
            }

            sortAscBtn.classList.remove('active');
            sortDescBtn.classList.remove('active');
            sortAlphaAscBtn.classList.remove('active');
            sortAlphaDescBtn.classList.remove('active');

            if (order === 'asc') {
                sortAscBtn.classList.add('active');
                communeDataList.sort((a, b) => (a.price ?? 0) - (b.price ?? 0));
            } else if (order === 'desc') {
                sortDescBtn.classList.add('active');
                communeDataList.sort((a, b) => (b.price ?? 0) - (a.price ?? 0));
            } else if (order === 'alphaAsc') {
                sortAlphaAscBtn.classList.add('active');
                communeDataList.sort((a, b) => a.name.localeCompare(b.name));
            } else if (order === 'alphaDesc') {
                sortAlphaDescBtn.classList.add('active');
                communeDataList.sort((a, b) => b.name.localeCompare(a.name));
            }

            list.innerHTML = '';
            communeDataList.forEach(commune => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span>${commune.name}</span>
                    <span class="price">${commune.price ? commune.price.toFixed(1) : 'N/A'} ‚Ç¨/m¬≤</span>
                `;
                li.onclick = () => {
                    centerCommune(commune.layer);
                    highlightSearchResult(commune.code, false);
                    commune.layer.openPopup();
                };
                list.appendChild(li);
            });
        }

        function closeCommuneList() {
            const container = document.getElementById('communeListContainer');
            container.style.display = 'none';
            currentDeptCode = null;
            communeDataList = [];

            departementsLayer.eachLayer(layer => {
                const style = getLayerStyle(layer.feature, prixData);
                layer.setStyle(style);
                layer.currentStyle = style;
            });

            if (communesLayer) {
                map.removeLayer(communesLayer);
                communesLayer = null;
            }
        }

        function updateLegend() {
            const legend = L.control({ position: 'bottomright' });
            legend.onAdd = function() {
                const div = L.DomUtil.create('div', 'info legend');
                const grades = [4000, 3500, 3000, 2500, 2000, 1500, 1000]; // Inverser l'ordre des seuils
                let html = `<b>Prix du m¬≤ (2023)</b><br>`;
                html += '<i style="background:#800026"></i> > 4000 ‚Ç¨/m¬≤<br>';
                for (let i = 0; i < grades.length - 1; i++) {
                    html += `<i style="background:${getColor(grades[i] - 1)}"></i> ${grades[i + 1]}‚Äì${grades[i]} ‚Ç¨/m¬≤<br>`;
                }
                html += '<i style="background:#F5F5DC"></i> < 1000 ‚Ç¨/m¬≤<br>';
                html += '<br><i style="background:#808080"></i> Donn√©es non disponibles<br>';
                div.innerHTML = html;
                return div;
            };
            if (map._legend) map.removeControl(map._legend);
            map._legend = legend.addTo(map);
        }

        function highlightSearchResult(code, isDepartment) {
            if (searchHighlightedLayer) {
                departementsLayer.eachLayer(layer => {
                    const style = getLayerStyle(layer.feature, prixData, false, false, layer.feature.properties.code.toString().padStart(2, '0') === currentDeptCode);
                    layer.setStyle(style);
                    layer.currentStyle = style;
                });
                if (communesLayer) {
                    communesLayer.eachLayer(layer => {
                        const style = getLayerStyle(layer.feature, prixCommuneData, layer === searchHighlightedLayer);
                        layer.setStyle(style);
                        layer.currentStyle = style;
                    });
                }
                searchHighlightedLayer = null;
            }

            if (isDepartment) {
                searchHighlightedLayer = Object.values(departementsLayer._layers).find(layer =>
                    layer.feature.properties.code.toString().padStart(2, '0') === code
                );
                if (searchHighlightedLayer) {
                    const highlightedStyle = getLayerStyle(searchHighlightedLayer.feature, prixData, true);
                    searchHighlightedLayer.setStyle(highlightedStyle);
                    searchHighlightedLayer.currentStyle = highlightedStyle;
                    searchHighlightedLayer.openPopup();
                }
            } else {
                if (communesLayer) {
                    searchHighlightedLayer = Object.values(communesLayer._layers).find(layer =>
                        layer.feature.properties.codgeo === code
                    );
                    if (searchHighlightedLayer) {
                        const highlightedStyle = getLayerStyle(searchHighlightedLayer.feature, prixCommuneData, true);
                        searchHighlightedLayer.setStyle(highlightedStyle);
                        searchHighlightedLayer.currentStyle = highlightedStyle;
                        searchHighlightedLayer.openPopup();
                    }
                }
            }

            departementsLayer.eachLayer(layer => {
                const deptCode = layer.feature.properties.code.toString().padStart(2, '0');
                if (deptCode === currentDeptCode) {
                    const selectedStyle = getLayerStyle(layer.feature, prixData, false, false, true);
                    layer.setStyle(selectedStyle);
                    layer.currentStyle = selectedStyle;
                } else if (layer !== searchHighlightedLayer) {
                    const fadedStyle = getLayerStyle(layer.feature, prixData, false, true);
                    layer.setStyle(fadedStyle);
                    layer.currentStyle = fadedStyle;
                }
            });

            if (communesLayer) {
                if (isDepartment) {
                    communesLayer.eachLayer(layer => {
                        const style = getLayerStyle(layer.feature, prixCommuneData, false, false);
                        layer.setStyle(style);
                        layer.currentStyle = style;
                    });
                } else {
                    communesLayer.eachLayer(layer => {
                        if (layer !== searchHighlightedLayer) {
                            const fadedStyle = getLayerStyle(layer.feature, prixCommuneData, false, true);
                            layer.setStyle(fadedStyle);
                            layer.currentStyle = fadedStyle;
                        }
                    });
                }
            }
        }

        const searchControl = L.control({ position: 'topleft' });
        searchControl.onAdd = function() {
            const div = L.DomUtil.create('div', 'leaflet-control-search');
            div.innerHTML = `
                <input type="text" id="mapSearch" placeholder="Rechercher un d√©partement/commune...">
                <ul id="mapSuggestions"></ul>
            `;
            L.DomEvent.disableClickPropagation(div);
            return div;
        };
        searchControl.addTo(map);

        document.getElementById('mapSearch').addEventListener('input', function() {
            const input = this.value;
            const normalizedInput = normalizeString(input);
            const suggestions = document.getElementById('mapSuggestions');
            suggestions.innerHTML = '';

            if (input.length === 0) {
                suggestions.style.display = 'none';
                if (searchHighlightedLayer) {
                    departementsLayer.eachLayer(layer => {
                        const style = getLayerStyle(layer.feature, prixData, false, false, layer.feature.properties.code.toString().padStart(2, '0') === currentDeptCode);
                        layer.setStyle(style);
                        layer.currentStyle = style;
                    });
                    if (communesLayer) {
                        communesLayer.eachLayer(layer => {
                            const style = getLayerStyle(layer.feature, prixCommuneData);
                            layer.setStyle(style);
                            layer.currentStyle = style;
                        });
                    }
                    searchHighlightedLayer = null;
                }
                return;
            }

            if (input.length < 2) {
                suggestions.style.display = 'none';
                if (searchHighlightedLayer) {
                    departementsLayer.eachLayer(layer => {
                        const deptCode = layer.feature.properties.code.toString().padStart(2, '0');
                        if (deptCode === currentDeptCode) {
                            const selectedStyle = getLayerStyle(layer.feature, prixData, false, false, true);
                            layer.setStyle(selectedStyle);
                            layer.currentStyle = selectedStyle;
                        } else if (layer !== searchHighlightedLayer) {
                            const fadedStyle = getLayerStyle(layer.feature, prixData, false, true);
                            layer.setStyle(fadedStyle);
                            layer.currentStyle = fadedStyle;
                        }
                    });
                    if (communesLayer) {
                        if (searchHighlightedLayer.feature.properties.codgeo) {
                            communesLayer.eachLayer(layer => {
                                if (layer !== searchHighlightedLayer) {
                                    const fadedStyle = getLayerStyle(layer.feature, prixCommuneData, false, true);
                                    layer.setStyle(fadedStyle);
                                    layer.currentStyle = fadedStyle;
                                }
                            });
                        } else {
                            communesLayer.eachLayer(layer => {
                                const style = getLayerStyle(layer.feature, prixCommuneData, false, false);
                                layer.setStyle(style);
                                layer.currentStyle = style;
                            });
                        }
                    }
                }
                return;
            }

            const deptMatches = Object.entries(deptNames).filter(([code, info]) =>
                code.includes(input) || info.normalizedName.includes(normalizedInput)
            );

            const communeMatches = Object.entries(communeNames).filter(([code, info]) =>
                code.includes(input) || info.normalizedName.includes(normalizedInput)
            );

            const matches = [
                ...deptMatches.map(([code, info]) => ({ type: 'dept', code, name: info.name })),
                ...communeMatches.map(([code, info]) => ({ type: 'commune', code, ...info }))
            ];

            matches.slice(0, 5).forEach(match => {
                const li = document.createElement('li');
                li.textContent = match.type === 'dept' ? `${match.name} (D√©p. ${match.code})` : `${match.name} (${match.depName})`;
                li.onclick = () => {
                    if (match.type === 'dept') {
                        const feature = Object.values(departementsLayer._layers).find(layer =>
                            layer.feature.properties.code.toString().padStart(2, '0') === match.code
                        );
                        if (feature) {
                            const bounds = feature.getBounds();
                            map.fitBounds(bounds, { maxZoom: 9, animate: true });
                            const center = bounds.getCenter();
                            adjustCenterForSearch(center, map.getZoom());
                            loadCommuneLayer(match.code, true);
                            highlightSearchResult(match.code, true);
                        }
                    } else {
                        const feature = Object.values(communesLayer?._layers || {}).find(layer =>
                            layer?.feature?.properties?.codgeo === match.code
                        );
                        if (feature) {
                            centerCommune(feature, true);
                        } else {
                            const center = [match.lat, match.lng];
                            // S'assurer que le centre est dans les limites
                            const boundedCenter = [
                                Math.max(franceBounds[0][0], Math.min(franceBounds[1][0], center[0])),
                                Math.max(franceBounds[0][1], Math.min(franceBounds[1][1], center[1]))
                            ];
                            map.setView(boundedCenter, 13, { animate: true });
                            adjustCenterForSearch(boundedCenter, 13);
                        }
                        loadCommuneLayer(match.dep, false);
                        highlightSearchResult(match.code, false);
                    }
                    document.getElementById('mapSearch').value = '';
                    suggestions.style.display = 'none';
                };
                suggestions.appendChild(li);
            });

            suggestions.style.display = matches.length > 0 ? 'block' : 'none';
        });

        const resetControl = L.control({ position: 'topleft' });
        resetControl.onAdd = function() {
            const div = L.DomUtil.create('div', 'leaflet-control-reset');
            div.innerHTML = 'R√©initialiser la vue';
            L.DomEvent.on(div, 'click', () => {
                map.setView(initialView.center, initialView.zoom, { animate: true });
                if (communesLayer) map.removeLayer(communesLayer);
                if (searchHighlightedLayer) {
                    departementsLayer.eachLayer(layer => {
                        const style = getLayerStyle(layer.feature, prixData);
                        layer.setStyle(style);
                        layer.currentStyle = style;
                    });
                    if (communesLayer) {
                        communesLayer.eachLayer(layer => {
                            const style = getLayerStyle(layer.feature, prixCommuneData);
                            layer.setStyle(style);
                            layer.currentStyle = style;
                        });
                    }
                    searchHighlightedLayer = null;
                }
                closeCommuneList();
                currentDeptCode = null;
            });
            L.DomEvent.disableClickPropagation(div);
            return div;
        };
        resetControl.addTo(map);

        const statsPanel = L.control({ position: 'bottomleft' });
        statsPanel.onAdd = function() {
            const div = L.DomUtil.create('div', 'leaflet-control-stats');
            div.id = 'statsPanel';
            div.innerHTML = `
                <h4>Statistiques</h4>
                <p>S√©lectionnez un d√©partement ou une commune pour voir les d√©tails.</p>
            `;
            L.DomEvent.disableClickPropagation(div);
            return div;
        };
        statsPanel.addTo(map);

        function updateStatsPanel(name, code, prix, depName) {
            const statsPanel = document.getElementById('statsPanel');
            if (!name) {
                statsPanel.innerHTML = `
                    <h4>Statistiques</h4>
                    <p>S√©lectionnez un d√©partement ou une commune pour voir les d√©tails.</p>
                `;
                return;
            }

            if (depName) {
                statsPanel.innerHTML = `
                    <h4>Commune : ${name}</h4>
                    <p><strong>Code :</strong> ${code}</p>
                    <p><strong>D√©partement :</strong> ${depName}</p>
                    <p><strong>Prix moyen :</strong> ${prix}</p>
                `;
            } else {
                const avgPrice = Object.values(prixData).reduce((a, b) => a + b, 0) / Object.keys(prixData).length;
                statsPanel.innerHTML = `
                    <h4>D√©partement : ${name}</h4>
                    <p><strong>Code :</strong> ${code}</p>
                    <p><strong>Prix moyen (2023) :</strong> ${prix}</p>
                    <p><strong>Moyenne nationale :</strong> ${avgPrice.toFixed(1)} ‚Ç¨/m¬≤</p>
                `;
            }
        }

        const closeCommuneListBtn = document.getElementById('closeCommuneListBtn');
        const sortAscBtn = document.getElementById('sortAsc');
        const sortDescBtn = document.getElementById('sortDesc');
        const sortAlphaAscBtn = document.getElementById('sortAlphaAsc');
        const sortAlphaDescBtn = document.getElementById('sortAlphaDesc');

        if (closeCommuneListBtn) {
            closeCommuneListBtn.addEventListener('click', closeCommuneList);
        }

        if (sortAscBtn) {
            sortAscBtn.addEventListener('click', () => sortCommunes('asc'));
        }

        if (sortDescBtn) {
            sortDescBtn.addEventListener('click', () => sortCommunes('desc'));
        }

        if (sortAlphaAscBtn) {
            sortAlphaAscBtn.addEventListener('click', () => sortCommunes('alphaAsc'));
        }

        if (sortAlphaDescBtn) {
            sortAlphaDescBtn.addEventListener('click', () => sortCommunes('alphaDesc'));
        }

        updateLayer();
    }).catch(error => {
        console.error('Erreur lors du chargement des donn√©es initiales pour Leaflet :', error);
    });
}

// MAP 3D (CESIUM)
function initCesium() {
    const loadingSpinner = document.getElementById('loadingSpinner');
    loadingSpinner.style.display = 'block';

    const viewer = new Cesium.Viewer('map3D', {
        imageryProvider: new Cesium.OpenStreetMapImageryProvider({ url: 'https://a.tile.openstreetmap.org/' }),
        terrainProvider: null,
        baseLayerPicker: false,
        geocoder: false,
        homeButton: true,
        sceneModePicker: true,
        navigationHelpButton: true,
        animation: false,
        timeline: false,
        fullscreenButton: false, // D√©sactiver le bouton plein √©cran
        infoBox: false,
        selectionIndicator: false
    });

    // Stocker le viewer globalement pour y acc√©der plus tard
    window.cesiumViewer = viewer;

    viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#87CEEB');
    viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(2.5, 46.5, 400000),
        orientation: { heading: Cesium.Math.toRadians(0.0), pitch: Cesium.Math.toRadians(-60.0) }
    });

    Promise.all([
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/prix_m2_moyenne_par_commune.csv').then(response => response.text()),
        fetch('https://www.data.gouv.fr/fr/datasets/r/fb3580f6-e875-408d-809a-ad22fc418581').then(response => response.json()),
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/ne_50m_admin_0_countries.geojson').then(response => response.json()),
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/contour-des-departements.geojson').then(response => response.json())
    ]).then(([csvText, communeGeojsonData, countriesGeojsonData, deptGeojsonData]) => {
        let rows = csvText.split("\n").map(row => row.split(";"));
        rows.forEach(row => {
            let code_commune = row[0]?.trim().padStart(5, '0');
            let prix = parseFloat(row[1]);
            if (code_commune && !isNaN(prix)) prixCommuneData[code_commune] = prix;
        });

        Cesium.GeoJsonDataSource.load(countriesGeojsonData, {
            clampToGround: true,
            stroke: Cesium.Color.BLACK,
            strokeWidth: 1,
            fill: Cesium.Color.GRAY.withAlpha(0.3)
        }).then(dataSource => {
            viewer.dataSources.add(dataSource);
        });

        Cesium.GeoJsonDataSource.load(communeGeojsonData, { clampToGround: false }).then(dataSource => {
            viewer.dataSources.add(dataSource);
            const entities = dataSource.entities.values;
            const domDepartments = ["971", "972", "973", "974", "975", "976", "977", "978", "986", "987", "988"];

            entities.forEach(entity => {
                const dep = entity.properties._dep ? entity.properties._dep._value.toString().padStart(2, '0') : null;
                if (dep && domDepartments.includes(dep)) {
                    entity.show = false;
                    return;
                }

                const code = entity.properties._codgeo._value;
                const prix = prixCommuneData[code];
                const height = prix !== undefined ? prix * 30 : 0;
                const fillColor = prix !== undefined ? Cesium.Color.fromCssColorString(getColor(prix)).withAlpha(1.0) : Cesium.Color.fromCssColorString('#808080').withAlpha(1.0);
                entity.polygon.material = fillColor;
                entity.polygon.outline = true;
                entity.polygon.outlineColor = fillColor;
                entity.polygon.extrudedHeight = height;
                entity.polygon.height = 0;

                // Ajouter un gestionnaire de clic pour afficher les infos dans l'encadr√©
                entity.properties.clickHandler = new Cesium.CallbackProperty(() => {
                    const communeName = entity.properties._libgeo ? entity.properties._libgeo._value : 'Nom non d√©fini';
                    const prixText = prix !== undefined ? prix.toFixed(1) + " ‚Ç¨/m¬≤" : "Donn√©e non disponible";
                    showCommuneInfo(communeName, code, prixText);
                }, false);
            });

            // Activer la s√©lection au clic
            const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
            handler.setInputAction(function (click) {
                const pickedObject = viewer.scene.pick(click.position);
                if (Cesium.defined(pickedObject) && pickedObject.id && pickedObject.id.properties.clickHandler) {
                    pickedObject.id.properties.clickHandler.getValue();
                } else {
                    // Cacher l'encadr√© si on clique ailleurs
                    hideCommuneInfo();
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

            const legendDiv = document.createElement('div');
            legendDiv.id = 'legend3D';
            legendDiv.innerHTML = `
                <b>Prix du m¬≤</b><br>
                <div><span style="display:inline-block;width:18px;height:18px;background:#800026"></span> > 4000 ‚Ç¨/m¬≤</div>
                <div><span style="display:inline-block;width:18px;height:18px;background:#BD0026"></span> 4000‚Äì3500 ‚Ç¨/m¬≤</div>
                <div><span style="display:inline-block;width:18px;height:18px;background:#E31A1C"></span> 3500‚Äì3000 ‚Ç¨/m¬≤</div>
                <div><span style="display:inline-block;width:18px;height:18px;background:#FC4E2A"></span> 3000‚Äì2500 ‚Ç¨/m¬≤</div>
                <div><span style="display:inline-block;width:18px;height:18px;background:#FD8D3C"></span> 2500‚Äì2000 ‚Ç¨/m¬≤</div>
                <div><span style="display:inline-block;width:18px;height:18px;background:#FEB24C"></span> 2000‚Äì1500 ‚Ç¨/m¬≤</div>
                <div><span style="display:inline-block;width:18px;height:18px;background:#FED976"></span> 1500‚Äì1000 ‚Ç¨/m¬≤</div>
                <div><span style="display:inline-block;width:18px;height:18px;background:#F5F5DC"></span> < 1000 ‚Ç¨/m¬≤</div>
                <br><div><span style="display:inline-block;width:18px;height:18px;background:#808080"></span> Donn√©es non disponibles</div>
            `;
            document.getElementById('map3D').appendChild(legendDiv);

            const controlsDiv = document.createElement('div');
            controlsDiv.id = 'controls3D';
            controlsDiv.innerHTML = '<b>S√©lectionner un d√©partement :</b>';
            const select = document.createElement('select');
            select.innerHTML = '<option value="">Toute la France</option>';
            deptGeojsonData.features.forEach(feature => {
                const option = document.createElement('option');
                option.value = feature.properties.code.toString().padStart(2, '0');
                option.text = feature.properties.nom;
                select.appendChild(option);
            });

            select.onchange = function() {
                const codeDep = select.value;
                if (codeDep) {
                    const depFeature = deptGeojsonData.features.find(f => f.properties.code.toString().padStart(2, '0') === codeDep);
                    const bounds = calculateBounds(depFeature);
                    viewer.camera.flyTo({ destination: bounds, duration: 1.5 });

                    entities.forEach(entity => {
                        const entityDep = entity.properties._dep ? entity.properties._dep._value.toString().padStart(2, '0') : null;
                        entity.show = entityDep === codeDep && !domDepartments.includes(entityDep);
                    });
                } else {
                    viewer.camera.flyTo({
                        destination: Cesium.Cartesian3.fromDegrees(2.5, 46.5, 400000),
                        orientation: { heading: Cesium.Math.toRadians(0.0), pitch: Cesium.Math.toRadians(-60.0) },
                        duration: 1.5
                    });
                    entities.forEach(entity => {
                        const entityDep = entity.properties._dep ? entity.properties._dep._value.toString().padStart(2, '0') : null;
                        entity.show = !domDepartments.includes(entityDep);
                    });
                }
            };

            controlsDiv.appendChild(select);
            document.getElementById('map3D').appendChild(controlsDiv);
        });

        // Gestionnaire pour le bouton de fermeture
        const closeCommuneInfoBtn = document.getElementById('closeCommuneInfoBtn');
        closeCommuneInfoBtn.addEventListener('click', hideCommuneInfo);

        loadingSpinner.style.display = 'none';
    }).catch(error => {
        console.error('Erreur lors du chargement des donn√©es pour Cesium :', error);
        loadingSpinner.style.display = 'none';
    });

    function calculateBounds(feature) {
        let coordinates = feature.geometry.coordinates;
        let minLon = Infinity, maxLon = -Infinity, minLat = Infinity, maxLat = -Infinity;

        function processCoords(coords) {
            if (Array.isArray(coords[0])) {
                coords.forEach(subCoords => processCoords(subCoords));
            } else {
                let lon = coords[0];
                let lat = coords[1];
                minLon = Math.min(minLon, lon);
                maxLon = Math.max(maxLon, lon);
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
            }
        }

        if (feature.geometry.type === "Polygon") {
            processCoords(coordinates[0]);
        } else if (feature.geometry.type === "MultiPolygon") {
            coordinates.forEach(poly => processCoords(poly[0]));
        }

        return Cesium.Rectangle.fromDegrees(minLon, minLat, maxLon, maxLat);
    }

    // Fonction pour afficher les informations dans l'encadr√©
    function showCommuneInfo(name, code, price) {
        const infoBox = document.getElementById('communeInfoBox');
        const nameElement = document.getElementById('communeInfoName');
        const codeElement = document.getElementById('communeInfoCode');
        const priceElement = document.getElementById('communeInfoPrice');
        const wikiLink = document.getElementById('communeInfoWikiLink');

        nameElement.textContent = name;
        codeElement.textContent = code;
        priceElement.textContent = price;
        wikiLink.href = getWikipediaUrl(name);

        infoBox.style.display = 'block';
    }

    // Fonction pour masquer l'encadr√©
    function hideCommuneInfo() {
        const infoBox = document.getElementById('communeInfoBox');
        infoBox.style.display = 'none';
    }
}

// Histogram
function initHistogram() {
    Promise.all([
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/prix_m2_moyenne_par_departement.csv').then(response => response.text()),
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/contour-des-departements.geojson').then(response => response.json())
    ]).then(([csvText, deptGeojsonData]) => {
        let rows = csvText.split("\n").map(row => row.split(";"));
        let deptData = [];
        let deptNames = {};

        deptGeojsonData.features.forEach(feature => {
            const code = feature.properties.code.toString().padStart(2, '0');
            deptNames[code] = feature.properties.nom;
        });

        rows.forEach(row => {
            let code_dept = row[0]?.trim().padStart(2, '0');
            let prix = parseFloat(row[1]);
            if (code_dept && !isNaN(prix) && deptNames[code_dept]) {
                deptData.push({ code: code_dept, prix: prix, nom: deptNames[code_dept] });
            }
        });

        // Fonction pour trier et mettre √† jour l'histogramme
        function updateHistogram() {
            const sortOption = document.getElementById('sortOptions').value;

            let sortedData = [...deptData];

            // Appliquer le tri selon l'option s√©lectionn√©e
            if (sortOption === 'priceAsc') {
                sortedData.sort((a, b) => a.prix - b.prix);
            } else if (sortOption === 'priceDesc') {
                sortedData.sort((a, b) => b.prix - a.prix);
            } else if (sortOption === 'deptAsc') {
                sortedData.sort((a, b) => a.code.localeCompare(b.code));
            } else if (sortOption === 'deptDesc') {
                sortedData.sort((a, b) => b.code.localeCompare(a.code));
            }

            // Mettre √† jour les donn√©es de l'histogramme
            const labels = sortedData.map(d => `${d.nom} (${d.code})`);
            const prices = sortedData.map(d => d.prix);
            const colors = prices.map(prix => getColor(prix));

            histogramChart.data.labels = labels;
            histogramChart.data.datasets[0].data = prices;
            histogramChart.data.datasets[0].backgroundColor = colors;
            histogramChart.data.datasets[0].borderColor = colors;
            histogramChart.update();
        }

        // Cr√©er l'histogramme initial
        const ctx = document.getElementById('histogramChart').getContext('2d');
        const histogramChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: deptData.map(d => `${d.nom} (${d.code})`),
                datasets: [{
                    label: 'Prix moyen au m¬≤ (‚Ç¨)',
                    data: deptData.map(d => d.prix),
                    backgroundColor: deptData.map(d => getColor(d.prix)),
                    borderColor: deptData.map(d => getColor(d.prix)),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Prix moyen au m¬≤ (‚Ç¨)',
                            font: { size: 14, family: 'Poppins' }
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.1)' }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'D√©partements',
                            font: { size: 14, family: 'Poppins' }
                        },
                        ticks: { autoSkip: false, maxRotation: 90, minRotation: 90, font: { size: 10 } }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Prix moyen : ${context.raw.toFixed(1)} ‚Ç¨/m¬≤`;
                            }
                        }
                    }
                }
            }
        });

        // Ajouter un √©couteur d'√©v√©nements pour le menu de tri
        document.getElementById('sortOptions').addEventListener('change', updateHistogram);

        // Stocker le graphique pour une utilisation future
        window.histogramChart = histogramChart;
    }).catch(error => {
        console.error('Erreur lors du chargement des donn√©es pour l\'histogramme :', error);
    });
}

// Comparison Tab (2014-2023)
function initComparison() {
    // D√©finir les limites g√©ographiques de la France m√©tropolitaine
    const franceBounds = [
        [41.5, -5.5], // Coin sud-ouest (lat, lng)
        [51.5, 9.5]   // Coin nord-est (lat, lng)
    ];

    mapComparison = L.map('mapComparison', {
        zoomAnimation: true,
        zoomDelta: 0.5,
        zoomSnap: 0.5,
        maxZoom: 10,
        minZoom: 5,
        // Ajouter les limites pour emp√™cher de sortir de la France m√©tropolitaine
        maxBounds: franceBounds,
        maxBoundsViscosity: 1.0, // Emp√™che compl√®tement le d√©placement hors des limites
        bounceAtZoomLimits: false // D√©sactive le rebond aux limites de zoom
    }).setView([46.5, 2.0], 5.5);

    const initialViewComparison = { center: [46.5, 2.0], zoom: 5.5 }; // Vue initiale pour la carte de comparaison

    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles ¬© Esri ‚Äî Esri, DeLorme, NAVTEQ',
        maxZoom: 16
    }).addTo(mapComparison);

    let prixDataByYear = {};
    let deptGeojsonData = null;
    let searchHighlightedLayer = null; // Variable pour suivre la couche mise en surbrillance dans la carte de comparaison
    const years = Array.from({ length: 2023 - 2014 + 1 }, (_, i) => 2014 + i);

    const fetchPromises = years.map(year => {
        let url = year === 2014 ? 
            'https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/Prix_m2_par_dep_2014.csv' :
            year === 2023 ? 
            'https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/prix_m2_moyenne_par_departement.csv' :
            `https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/prix_m2_2014_a_2023/prix_m2_${year}.csv`;
        return fetch(url)
            .then(response => response.text())
            .then(text => ({ year, text }))
            .catch(error => {
                console.error(`Erreur pour ${year} :`, error);
                return { year, text: null };
            });
    });

    Promise.all([
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/ne_50m_admin_0_countries.geojson').then(response => response.json()),
        fetch('https://raw.githubusercontent.com/Aprz00/projet_dataviz/main/contour-des-departements.geojson').then(response => response.json()),
        ...fetchPromises
    ]).then(([countriesGeojson, deptGeojsonDataResponse, ...yearData]) => {
        deptGeojsonData = deptGeojsonDataResponse;

        // Load Department Names with normalized version for search
        deptGeojsonData.features.forEach(feature => {
            let code = feature.properties.code.toString().padStart(2, '0');
            let name = feature.properties.nom || 'Nom non d√©fini';
            deptNames[code] = {
                name: name,
                normalizedName: normalizeString(name) // Ajout de la version normalis√©e
            };
        });

        L.geoJSON(countriesGeojson, {
            style: { fillColor: '#f0f0f0', weight: 1, opacity: 1, color: '#666', fillOpacity: 0.8 }
        }).addTo(mapComparison);

        let deptCodes = deptGeojsonData.features.map(feature => feature.properties.code.toString().trim());

        yearData.forEach(({ year, text }) => {
            prixDataByYear[year] = {};
            if (!text) return;
            let delimiter = year === 2023 ? ";" : ",";
            let rows = text.split("\n").map(row => row.split(delimiter));
            let startIndex = (rows[0][1] && rows[0][1].trim() === "prix_m2") ? 1 : 0;

            rows.slice(startIndex).forEach(row => {
                if (row.length < 2) return;
                let code_dep = row[0]?.trim();
                let prix = parseFloat(row[1]);
                if (!code_dep || isNaN(prix)) return;
                code_dep = code_dep.padStart(2, '0');
                if (deptCodes.includes(code_dep)) prixDataByYear[year][code_dep] = prix;
            });
        });

        // Fonction pour obtenir le style d'une couche dans la carte de comparaison
        function getComparisonLayerStyle(feature, prixData, isHighlighted = false, isFaded = false) {
            let code = feature.properties.code.toString().trim();
            let prix = prixData[code];
            let fillColor = getColor(prix);

            if (isHighlighted) {
                return {
                    fillColor: fillColor,
                    weight: 3,
                    opacity: 1,
                    color: '#FFFFFF', // Contour blanc pour la surbrillance
                    fillOpacity: 0.9
                };
            }

            if (isFaded) {
                return {
                    fillColor: fillColor,
                    weight: 1,
                    opacity: 0.15,
                    color: 'black',
                    fillOpacity: 0.15
                };
            }

            return {
                fillColor: prix !== undefined ? fillColor : '#808080',
                weight: 1,
                opacity: 1,
                color: 'black',
                fillOpacity: 0.7
            };
        }

        // Fonction pour mettre en surbrillance un d√©partement dans la carte de comparaison
        function highlightComparisonDepartment(code) {
            // R√©initialiser l'ancienne surbrillance
            if (searchHighlightedLayer) {
                departementsLayer.eachLayer(layer => {
                    const year = document.getElementById('yearSlider').value;
                    const prixData = prixDataByYear[year] || {};
                    const style = getComparisonLayerStyle(layer.feature, prixData);
                    layer.setStyle(style);
                    layer.currentStyle = style;
                });
                searchHighlightedLayer = null;
            }

            // Trouver la couche correspondante
            searchHighlightedLayer = Object.values(departementsLayer._layers).find(layer =>
                layer.feature.properties.code.toString().padStart(2, '0') === code
            );

            if (searchHighlightedLayer) {
                const year = document.getElementById('yearSlider').value;
                const prixData = prixDataByYear[year] || {};
                const highlightedStyle = getComparisonLayerStyle(searchHighlightedLayer.feature, prixData, true);
                searchHighlightedLayer.setStyle(highlightedStyle);
                searchHighlightedLayer.currentStyle = highlightedStyle;
                searchHighlightedLayer.openPopup(); // Ouvre le popup automatiquement
            }

            // Estomper les autres couches
            departementsLayer.eachLayer(layer => {
                if (layer !== searchHighlightedLayer) {
                    const year = document.getElementById('yearSlider').value;
                    const prixData = prixDataByYear[year] || {};
                    const fadedStyle = getComparisonLayerStyle(layer.feature, prixData, false, true);
                    layer.setStyle(fadedStyle);
                    layer.currentStyle = fadedStyle;
                }
            });
        }

        function updateLayer(year) {
            if (departementsLayer) {
                mapComparison.removeLayer(departementsLayer);
                departementsLayer = null; // Assurez-vous que la couche est bien r√©initialis√©e
            }

            let prixData = prixDataByYear[year] || {};
            departementsLayer = L.geoJSON(deptGeojsonData, {
                style: function(feature) {
                    return getComparisonLayerStyle(feature, prixData);
                },
                onEachFeature: function(feature, layer) {
                    let code = feature.properties.code.toString().padStart(2, '0');
                    let nom = deptNames[code]?.name || 'Nom non d√©fini';
                    let prix = prixData[code] ? prixData[code].toFixed(1) + " ‚Ç¨/m¬≤" : "Donn√©e non disponible";

                    // Ajout du tooltip pour le survol
                    layer.bindTooltip(
                        `${nom}<br>${prix}`,
                        {
                            direction: 'top',
                            offset: [0, -10],
                            className: 'leaflet-tooltip-comparison' // Utiliser une classe sp√©cifique pour √©viter les conflits
                        }
                    );

                    // Popup au clic
                    layer.bindPopup(`
                        <div class="custom-popup">
                            <h3>${nom}</h3>
                            <p><strong>Code :</strong> ${code}</p>
                            <p><strong>Ann√©e :</strong> ${year}</p>
                            <p><strong>Prix moyen :</strong> ${prix}</p>
                        </div>
                    `);

                    // Gestion des √©v√©nements de survol
                    layer.on('mouseover', function() {
                        if (layer !== searchHighlightedLayer) {
                            layer.setStyle({
                                weight: 3,
                                color: '#000',
                                fillOpacity: 1
                            });
                        }
                        layer.openTooltip();
                    });

                    layer.on('mouseout', function() {
                        if (layer !== searchHighlightedLayer) {
                            layer.setStyle(layer.currentStyle || {
                                weight: 1,
                                color: 'black',
                                fillOpacity: 0.7
                            });
                        }
                        layer.closeTooltip();
                    });

                    // Gestion du clic pour garder la compatibilit√© avec le zoom
                    layer.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        mapComparison.fitBounds(layer.getBounds(), { maxZoom: 9, animate: true });
                        highlightComparisonDepartment(code);
                    });

                    // R√©initialisation du style apr√®s fermeture du popup
                    layer.on('popupclose', function() {
                        if (layer !== searchHighlightedLayer) {
                            layer.setStyle(layer.currentStyle || {
                                weight: 1,
                                color: 'black',
                                fillOpacity: 0.7
                            });
                        }
                    });
                }
            }).addTo(mapComparison);

            // Si un d√©partement est d√©j√† mis en surbrillance, le r√©appliquer apr√®s la mise √† jour de la couche
            if (searchHighlightedLayer) {
                const code = searchHighlightedLayer.feature.properties.code.toString().padStart(2, '0');
                highlightComparisonDepartment(code);
            }

            const legend = L.control({ position: 'bottomright' });
            legend.onAdd = function() {
                const div = L.DomUtil.create('div', 'info legend');
                const grades = [4000, 3500, 3000, 2500, 2000, 1500, 1000]; // Inverser l'ordre des seuils
                let html = `<b>Prix du m¬≤ (${year})</b><br>`;
                html += '<i style="background:#800026"></i> > 4000 ‚Ç¨/m¬≤<br>';
                for (let i = 0; i < grades.length - 1; i++) {
                    html += `<i style="background:${getColor(grades[i] - 1)}"></i> ${grades[i + 1]}‚Äì${grades[i]} ‚Ç¨/m¬≤<br>`;
                }
                html += '<i style="background:#F5F5DC"></i> < 1000 ‚Ç¨/m¬≤<br>';
                html += '<br><i style="background:#808080"></i> Donn√©es non disponibles<br>';
                div.innerHTML = html;
                return div;
            };
            if (mapComparison._legend) mapComparison.removeControl(mapComparison._legend);
            mapComparison._legend = legend.addTo(mapComparison);
        }

        // Reset View Control pour la carte de comparaison
        const resetControlComparison = L.control({ position: 'topleft' });
        resetControlComparison.onAdd = function() {
            const div = L.DomUtil.create('div', 'leaflet-control-reset');
            div.innerHTML = 'R√©initialiser la vue';
            L.DomEvent.on(div, 'click', () => {
                mapComparison.setView(initialViewComparison.center, initialViewComparison.zoom, { animate: true });
                if (searchHighlightedLayer) {
                    departementsLayer.eachLayer(layer => {
                        const year = document.getElementById('yearSlider').value;
                        const prixData = prixDataByYear[year] || {};
                        const style = getComparisonLayerStyle(layer.feature, prixData);
                        layer.setStyle(style);
                        layer.currentStyle = style;
                    });
                    searchHighlightedLayer = null;
                }
            });
            L.DomEvent.disableClickPropagation(div);
            return div;
        };
        resetControlComparison.addTo(mapComparison);

        function updatePriceTrendChart() {
            const ctx = document.getElementById('priceTrendChart').getContext('2d');
            if (priceTrendChart) {
                priceTrendChart.destroy();
                priceTrendChart = null;
            }

            priceTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: years,
                    datasets: [{
                        label: 'Prix moyen (‚Ç¨/m¬≤)',
                        data: years.map(y => {
                            let data = prixDataByYear[y] || {};
                            return Object.values(data).reduce((a, b) => a + b, 0) / (Object.keys(data).length || 1);
                        }),
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.2)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false }, tooltip: { mode: 'index', intersect: false } },
                    scales: {
                        x: { title: { display: true, text: 'Ann√©es' } },
                        y: { title: { display: true, text: 'Prix (‚Ç¨/m¬≤)' }, beginAtZero: true }
                    }
                }
            });
        }

        function updateNationalAverage() {
            const year = document.getElementById('yearSlider').value;
            const data = prixDataByYear[year] || {};
            const average = Object.values(data).reduce((a, b) => a + b, 0) / (Object.keys(data).length || 1);
            document.getElementById('nationalAverage').textContent = average.toFixed(1);
        }

        function zoomToDepartment(code) {
            if (!deptGeojsonData) return;
            const feature = deptGeojsonData.features.find(f => f.properties.code.toString().padStart(2, '0') === code);
            if (feature) {
                mapComparison.fitBounds(L.geoJSON(feature).getBounds(), { maxZoom: 9, animate: true });
                highlightComparisonDepartment(code); // Met en surbrillance et ouvre le popup
            }
        }

        window.updateYearSlider = function() {
            const year = document.getElementById('yearSlider').value;
            document.getElementById('yearDisplay').textContent = year;
            updateLayer(year);
            updateNationalAverage();
            updatePriceTrendChart();
        };

        window.filterDepartments = function() {
            const input = document.getElementById('deptSearch').value;
            const normalizedInput = normalizeString(input); // Normaliser l'entr√©e utilisateur
            const suggestions = document.getElementById('deptSuggestions');
            suggestions.innerHTML = '';
            if (input.length < 1) {
                suggestions.style.display = 'none';
                // R√©initialiser les styles si l'input est vide
                if (searchHighlightedLayer) {
                    departementsLayer.eachLayer(layer => {
                        const year = document.getElementById('yearSlider').value;
                        const prixData = prixDataByYear[year] || {};
                        const style = getComparisonLayerStyle(layer.feature, prixData);
                        layer.setStyle(style);
                        layer.currentStyle = style;
                    });
                    searchHighlightedLayer = null;
                }
                return;
            }
            const matches = Object.entries(deptNames).filter(([code, info]) =>
                code.includes(input) || info.normalizedName.includes(normalizedInput) // Comparer avec la version normalis√©e
            );
            matches.slice(0, 5).forEach(([code, info]) => {
                const li = document.createElement('li');
                li.textContent = `${info.name} (D√©p. ${code})`;
                li.onclick = () => {
                    zoomToDepartment(code);
                    document.getElementById('deptSearch').value = '';
                    suggestions.style.display = 'none';
                };
                suggestions.appendChild(li);
            });
            suggestions.style.display = matches.length > 0 ? 'block' : 'none';
        };

        updateLayer("2023");
        updateNationalAverage();
        updatePriceTrendChart();
    }).catch(error => {
        console.error('Erreur lors du chargement des donn√©es pour la comparaison :', error);
    });
}
function toggleFullscreen() {
    const image = document.getElementById('infographieImage');
    const button = document.getElementById('fullscreenBtn');

    if (!image.classList.contains('fullscreen')) {
        // Passer en mode plein √©cran
        image.classList.add('fullscreen');
        button.classList.add('fullscreen');
        button.textContent = 'R√©duire';
    } else {
        // Revenir au mode normal
        image.classList.remove('fullscreen');
        button.classList.remove('fullscreen');
        button.textContent = 'Plein √©cran';
    }
}
</script>
</body>
</html>
